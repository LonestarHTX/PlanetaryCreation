// Simplified GPU kernel for Stage B oceanic amplification.
#include "/Engine/Public/Platform.ush"
#include "/Plugin/PlanetaryCreation/Private/TectonicCommon.ush"

// Parameters bound from C++ via SHADER_PARAMETER_STRUCT
uint VertexCount;
float RidgeAmplitude;
float FaultFrequency;
float AgeFalloff;
StructuredBuffer<float> InBaseline;
StructuredBuffer<float4> InRidgeDirection;
StructuredBuffer<float> InCrustAge;
StructuredBuffer<float3> InRenderPosition;
StructuredBuffer<uint> InOceanicMask;
RWStructuredBuffer<float> OutAmplified;

static const int Permutation[512] = {
    63, 9, 212, 205, 31, 128, 72, 59, 137, 203, 195, 170, 181, 115, 165, 40, 116, 139, 175, 225, 132, 99, 222, 2, 41, 15, 197, 93, 169, 90, 228, 43,
    221, 38, 206, 204, 73, 17, 97, 10, 96, 47, 32, 138, 136, 30, 219, 78, 224, 13, 193, 88, 134, 211, 7, 112, 176, 19, 106, 83, 75, 217, 85,
    0, 98, 140, 229, 80, 118, 151, 117, 251, 103, 242, 81, 238, 172, 82, 110, 4, 227, 77, 243, 46, 12, 189, 34, 188, 200, 161, 68, 76, 171, 194,
    57, 48, 247, 233, 51, 105, 5, 23, 42, 50, 216, 45, 239, 148, 249, 84, 70, 125, 108, 241, 62, 66, 64, 240, 173, 185, 250, 49, 6, 37, 26, 21,
    244, 60, 223, 255, 16, 145, 27, 109, 58, 102, 142, 253, 120, 149, 160, 124, 156, 79, 186, 135, 127, 14, 121, 22, 65, 54, 153, 91, 213, 174, 24,
    252, 131, 192, 190, 202, 208, 35, 94, 231, 56, 95, 183, 163, 111, 147, 25, 67, 36, 92, 236, 71, 166, 1, 187, 100, 130, 143, 237, 178, 158, 104,
    184, 159, 177, 52, 214, 230, 119, 87, 114, 201, 179, 198, 3, 248, 182, 39, 11, 152, 196, 113, 20, 232, 69, 141, 207, 234, 53, 86, 180, 226, 74,
    150, 218, 29, 133, 8, 44, 123, 28, 146, 89, 101, 154, 220, 126, 155, 122, 210, 168, 254, 162, 129, 33, 18, 209, 61, 191, 199, 157, 245, 55, 164,
    167, 215, 246, 144, 107, 235,

    63, 9, 212, 205, 31, 128, 72, 59, 137, 203, 195, 170, 181, 115, 165, 40, 116, 139, 175, 225, 132, 99, 222, 2, 41, 15, 197, 93, 169, 90, 228, 43,
    221, 38, 206, 204, 73, 17, 97, 10, 96, 47, 32, 138, 136, 30, 219, 78, 224, 13, 193, 88, 134, 211, 7, 112, 176, 19, 106, 83, 75, 217, 85,
    0, 98, 140, 229, 80, 118, 151, 117, 251, 103, 242, 81, 238, 172, 82, 110, 4, 227, 77, 243, 46, 12, 189, 34, 188, 200, 161, 68, 76, 171, 194,
    57, 48, 247, 233, 51, 105, 5, 23, 42, 50, 216, 45, 239, 148, 249, 84, 70, 125, 108, 241, 62, 66, 64, 240, 173, 185, 250, 49, 6, 37, 26, 21,
    244, 60, 223, 255, 16, 145, 27, 109, 58, 102, 142, 253, 120, 149, 160, 124, 156, 79, 186, 135, 127, 14, 121, 22, 65, 54, 153, 91, 213, 174, 24,
    252, 131, 192, 190, 202, 208, 35, 94, 231, 56, 95, 183, 163, 111, 147, 25, 67, 36, 92, 236, 71, 166, 1, 187, 100, 130, 143, 237, 178, 158, 104,
    184, 159, 177, 52, 214, 230, 119, 87, 114, 201, 179, 198, 3, 248, 182, 39, 11, 152, 196, 113, 20, 232, 69, 141, 207, 234, 53, 86, 180, 226, 74,
    150, 218, 29, 133, 8, 44, 123, 28, 146, 89, 101, 154, 220, 126, 155, 122, 210, 168, 254, 162, 129, 33, 18, 209, 61, 191, 199, 157, 245, 55, 164,
    167, 215, 246, 144, 107, 235
};

int Perm(int Index)
{
    return Permutation[Index & 255];
}

float SmoothCurve(float X)
{
    return X * X * X * (X * (X * 6.0f - 15.0f) + 10.0f);
}

float Grad3(int Hash, float X, float Y, float Z)
{
    switch (Hash & 15)
    {
    case 0:  return X + Z;
    case 1:  return X + Y;
    case 2:  return Y + Z;
    case 3:  return -X + Y;
    case 4:  return -X + Z;
    case 5:  return -X - Y;
    case 6:  return -Y + Z;
    case 7:  return X - Y;
    case 8:  return X - Z;
    case 9:  return Y - Z;
    case 10: return -X - Z;
    case 11: return -Y - Z;
    case 12: return X + Y;
    case 13: return -X + Y;
    case 14: return -Y + Z;
    case 15: return -Y - Z;
    default: return 0.0f;
    }
}

float PerlinNoise3D(float3 Position)
{
    float3 FloorPos = floor(Position);
    int Xi = (int)FloorPos.x & 255;
    int Yi = (int)FloorPos.y & 255;
    int Zi = (int)FloorPos.z & 255;

    float X = Position.x - FloorPos.x;
    float Y = Position.y - FloorPos.y;
    float Z = Position.z - FloorPos.z;

    float Xm1 = X - 1.0f;
    float Ym1 = Y - 1.0f;
    float Zm1 = Z - 1.0f;

    int A  = Perm(Xi) + Yi;
    int AA = Perm(A) + Zi;
    int AB = Perm(A + 1) + Zi;
    int B  = Perm(Xi + 1) + Yi;
    int BA = Perm(B) + Zi;
    int BB = Perm(B + 1) + Zi;

    float U = SmoothCurve(X);
    float V = SmoothCurve(Y);
    float W = SmoothCurve(Z);

    float N000 = Grad3(Perm(AA),     X,   Y,   Z);
    float N100 = Grad3(Perm(BA),   Xm1,   Y,   Z);
    float N010 = Grad3(Perm(AB),     X, Ym1,   Z);
    float N110 = Grad3(Perm(BB),   Xm1, Ym1,   Z);
    float N001 = Grad3(Perm(AA + 1),   X,   Y, Zm1);
    float N101 = Grad3(Perm(BA + 1), Xm1,   Y, Zm1);
    float N011 = Grad3(Perm(AB + 1),   X, Ym1, Zm1);
    float N111 = Grad3(Perm(BB + 1), Xm1, Ym1, Zm1);

    float LerpX1 = lerp(N000, N100, U);
    float LerpX2 = lerp(N010, N110, U);
    float LerpX3 = lerp(N001, N101, U);
    float LerpX4 = lerp(N011, N111, U);

    float LerpY1 = lerp(LerpX1, LerpX2, V);
    float LerpY2 = lerp(LerpX3, LerpX4, V);

    float Result = lerp(LerpY1, LerpY2, W);
    return clamp(Result * 0.97f, -1.0f, 1.0f);
}

[numthreads(64, 1, 1)]
void MainCS(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    const uint Index = DispatchThreadID.x;
    if (Index >= VertexCount)
    {
        return;
    }

    const float Baseline = InBaseline[Index];

    if (InOceanicMask[Index] == 0u)
    {
        OutAmplified[Index] = Baseline;
        return;
    }

    const float CrustAge = InCrustAge[Index];
    float3 RidgeDir = normalize(InRidgeDirection[Index].xyz);
    float3 Position = InRenderPosition[Index];
    if (all(Position == 0.0f))
    {
        Position = float3(0.0f, 0.0f, 1.0f);
    }
    Position = normalize(Position);

    float3 FaultDir = normalize(cross(RidgeDir, Position));
    if (any(isnan(FaultDir)) || length(FaultDir) < 1e-5f)
    {
        FaultDir = normalize(cross(RidgeDir, float3(0.0f, 0.0f, 1.0f)));
        if (length(FaultDir) < 1e-5f)
        {
            FaultDir = normalize(cross(RidgeDir, float3(0.0f, 1.0f, 0.0f)));
        }
    }

    const float AgeFactor = (AgeFalloff > 0.0f) ? exp(-CrustAge * AgeFalloff) : 1.0f;
    const float FaultAmplitude = RidgeAmplitude * AgeFactor;

    const float3 SamplePoint1 = Position * FaultFrequency;
    const float3 SamplePoint2 = (Position + FaultDir * 2.0f) * FaultFrequency;
    const float Noise1 = PerlinNoise3D(SamplePoint1);
    const float Noise2 = PerlinNoise3D(SamplePoint2);
    const float NoiseValue = (abs(Noise1) > abs(Noise2)) ? Noise1 : Noise2;
    const float SharpNoise = (NoiseValue == 0.0f) ? 0.0f : sign(NoiseValue) * pow(abs(NoiseValue), 0.6f);
    const float GaborNoise = clamp(SharpNoise * 3.0f, -1.0f, 1.0f); // Scale up like CPU version (OceanicAmplification.cpp:183)
    const float FaultDetail = FaultAmplitude * GaborNoise;

    float GradientNoise = 0.0f;
    float Frequency = 0.1f;
    float Amplitude = 1.0f;
    [unroll]
    for (int Octave = 0; Octave < 4; ++Octave)
    {
        GradientNoise += PerlinNoise3D(Position * Frequency) * Amplitude;
        Frequency *= 2.0f;
        Amplitude *= 0.5f;
    }

    const float FineDetail = 20.0f * GradientNoise;
    OutAmplified[Index] = Baseline + FaultDetail + FineDetail;
}
